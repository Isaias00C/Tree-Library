<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>
	<body>
		<h2>Iniciar</h2>
		<button id="initButton">Iniciar</button>

		<br />
		<hr />

		<input type="text" placeholder="Nome do libro" id="titleInput" />
		<hr />
		<input type="text" placeholder="author" id="authorInput" />
		<hr />
		<input type="text" placeholder="ano" id="yearInput" />
		<hr />
		<input type="text" placeholder="stock" id="stockInput" />
		<hr />
		<input type="button" value="botao" id="submitButton" />
		<hr />

		<br />

		<h2>Procurar livro</h2>
		<input type="text" placeholder="Titulo" id="titleSearch" />
		<button id="searchButton">Buscar</button>

		<script type="module">
			import EmscriptenModule from "./AVL_Tree.mjs";

			EmscriptenModule().then((Module) => {
				console.log("Módulo WASM do processador de livros pronto!");

				const initButton = document.getElementById("initButton");

				initButton.addEventListener("click", () => {
					// 1. Aloca memória no lado do C/WASM e obtém um ponteiro.

					try {
						Module._initLibrary();
					} finally {
						// 5. ESSENCIAL: Libera a memória para evitar vazamentos, não importa o que aconteça.
						console.log(`Liberando a memória no endereço`);
					}
				});

				// --- Pega as referências dos elementos do formulário ---
				const titleInput = document.getElementById("titleInput");
				const authorInput = document.getElementById("authorInput");
				const yearInput = document.getElementById("yearInput");
				const stockInput = document.getElementById("stockInput");
				const submitButton = document.getElementById("submitButton");

				// --- Adiciona o evento de clique ao botão ---
				submitButton.addEventListener("click", () => {
					try {
						// 2. Pega os valores dos inputs do HTML.
						const title = titleInput.value;
						const author = authorInput.value;
						// Usamos parseInt para garantir que os números sejam inteiros.
						const year = parseInt(yearInput.value, 10) || 0;
						const stock = parseInt(stockInput.value, 10) || 0;

						// 3. Escreve os dados na memória do WASM, usando os offsets.
						// Para strings: stringToUTF8(stringJS, ponteiro, tamanho_max_bytes)

						Module._addBook(title, author, "abc123", year, stock);
						console.log("livro adicionado");
					} finally {
						// 5. ESSENCIAL: Libera a memória para evitar vazamentos, não importa o que aconteça.
						console.log(`livro adicionado2.`);
					}
				});

				const titleSearch = document.getElementById("titleSearch");
				const searchButton = document.getElementById("searchButton");

				searchButton.addEventListener("click", () => {
					try {
						// dentro do seu <script type="module"> e EmscriptenModule().then(Module => { ... })

						// 1. Crie o wrapper para a sua função
						// cwrap('nome_da_funcao_C', 'tipo_de_retorno_JS', ['tipos_de_argumentos_JS'])
						const searchAndGetJSON = Module.cwrap(
							"searchAndGetJSON",
							"string",
							["string"]
						);

						// 2. Chame a função como se fosse uma função JavaScript normal!
						const jsonResult = searchAndGetJSON(titleSearch.value); // O resultado já é uma string JS!

						console.log(titleSearch.value);
						// 3. Imprima e use o resultado
						console.log("String JSON recebida do C/WASM:");
						console.log(jsonResult);

						// Agora você pode até mesmo converter o JSON para um objeto JavaScript
						const data = JSON.parse(jsonResult);
						console.log("Objeto JavaScript convertido:");
						console.log(data);
					} finally {
						console.log("livro buscado");
					}
				});
			});
		</script>
	</body>
</html>
