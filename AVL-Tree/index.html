<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>
	<body>
		<button id="initButton">Iniciar</button>

		<input type="text" placeholder="Nome do libro" id="titleInput" />
		<input type="text" placeholder="author" id="authorInput" />
		<input type="text" placeholder="ano" id="yearInput" />
		<input type="text" placeholder="stock" id="stockInput" />
		<input type="button" placeholder="stock" id="submitButton" />

		<script type="module">
			import EmscriptenModule from "./AVL_Tree.mjs";

			EmscriptenModule().then((Module) => {
				console.log("Módulo WASM do processador de livros pronto!");

				const initButton = document.getElementById("initButton");

				initButton.addEventListener("click", () => {
					// 1. Aloca memória no lado do C/WASM e obtém um ponteiro.

					try {
						Module._initLibrary();
					} finally {
						// 5. ESSENCIAL: Libera a memória para evitar vazamentos, não importa o que aconteça.
						console.log(`Liberando a memória no endereço ${bookPtr}.`);
						Module._free_book_buffer(bookPtr);
					}
				});

				// --- Pega as referências dos elementos do formulário ---
				const titleInput = document.getElementById("titleInput");
				const authorInput = document.getElementById("authorInput");
				const yearInput = document.getElementById("yearInput");
				const stockInput = document.getElementById("stockInput");
				const submitButton = document.getElementById("submitButton");

				// --- Adiciona o evento de clique ao botão ---
				submitButton.addEventListener("click", () => {
					// 1. Aloca memória no lado do C/WASM e obtém um ponteiro.
					const bookPtr = Module._create_book_buffer();

					try {
						// 2. Pega os valores dos inputs do HTML.
						const title = titleInput.value;
						const author = authorInput.value;
						// Usamos parseInt para garantir que os números sejam inteiros.
						const year = parseInt(yearInput.value, 10) || 0;
						const stock = parseInt(stockInput.value, 10) || 0;

						// 3. Escreve os dados na memória do WASM, usando os offsets.
						// Para strings: stringToUTF8(stringJS, ponteiro, tamanho_max_bytes)
						Module.stringToUTF8(
							title,
							bookPtr + Module._get_title_offset(),
							256
						);
						Module.stringToUTF8(
							author,
							bookPtr + Module._get_author_offset(),
							128
						);

						// Para números: setValue(ponteiro, valor, tipo)
						Module.setValue(bookPtr + Module._get_year_offset(), year, "i32"); // i32 é um inteiro de 32 bits
						Module.setValue(bookPtr + Module._get_stock_offset(), stock, "i32");

						// 4. Agora que a memória está preenchida, chamamos a função C principal.
						console.log(`Passando o ponteiro ${bookPtr} para a função C...`);
						Module._process_book(bookPtr);
					} finally {
						// 5. ESSENCIAL: Libera a memória para evitar vazamentos, não importa o que aconteça.
						console.log(`Liberando a memória no endereço ${bookPtr}.`);
						Module._free_book_buffer(bookPtr);
					}
				});
			});
		</script>
	</body>
</html>
